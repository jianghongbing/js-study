# Map 

ES6提供了Map数据结构. 它类似于对象, 也是键值对的集合. 但是key的范围不限于字符串, 各种类型的值(包括对象)都可以当作键. 也就是说Object结构提供了字符串—值的对应, Map结构提供了值—值的对应, 是一种更完善的Hash结构实现. 如果你需要“键值对”的数据结构, Map比Object更合适. 一个Map对象在迭代时会根据对象中元素的插入顺序来进行, for...of循环在每次迭代后会返回一个形式为[ key，value ]的数组.

## Map中键的相等性

键的比较是基于SameValueZero算法, NaN是与NaN相等的(虽然 NaN !== NaN), 剩下所有其它的值是根据 === 运算符的结果判断是否相等. 

## Object和Map之间的比较

Objects和Map类似, 它们都允许你按键存取一个值、删除键、检测一个键是否绑定了值. 因此过去我们一直都把对象当成Map使用. 不过 Map和Object有一些重要的区别, 在下列情况里使用Map会是更好的选择:
* 一个Object的键只能是字符串或者Symbols, 但一个Map的键可以是任意值, 包括函数、对象、基本类型. 
* Map中的键值是有序的, 而添加到对象中的键则不是. 因此当对它进行遍历时, Map对象是按插入的顺序返回键值. 
* 可以通过size属性直接获取一个Map的键值对个数, 而Object的键值对个数只能手动计算. 
* Map可直接进行迭代, 而Object的迭代需要先获取它的键数组, 然后再进行迭代.
* Object都有自己的原型, 原型链上的键名有可能和你自己在对象上的设置的键名产生冲突.
* Map在涉及频繁增删键值对的场景下会有些性能优势.

## Map的属性和方法

* 构造函数: Map的构造函数接收一个遍历器对象, 并且遍历器对象中每个成员都是一个双元素的数组的数据结构. 每个键值对都会添加到新的Map. 不能使用Object对象来构建Map.
* size: Map中元素的个数
* set(key, value): 设置Map对象中键的值. 返回该Map对象. 
* has(key): 判断某个key是否存在
* get(key): 返回key对应的值, 如果不存在, 则返回undefined.
* forEach(): 按插入顺序, 为Map对象里的每一键值对调用一次callbackFn函数. 如果为forEach提供了thisArg, 它将在每次回调中作为this值. 
* keys(): 返回一个新的Iterator对象, 它按插入顺序包含了Map对象中每个元素的键. 
* values(): 返回一个新的Iterator对象, 它按插入顺序包含了Map对象中每个元素的值. 
* entries(): 返回一个新的Iterator对象, 它按插入顺序包含了Map对象中每个元素的[key, value]数组.
* delete(key): 如果Map对象中存在该元素, 则移除它并返回true, 否则如果该元素不存在则返回false
* clear(): 移除Map对象的所有键/值对.

