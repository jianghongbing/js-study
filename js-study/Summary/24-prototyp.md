# prototype: 原型

JavaScript中, 每个对象都有属性自己的原型, 原型本质上也是一个对象, 可以为其添加属性和方法. 

## 对象的原型

JavaScript常被描述为一种基于原型的语言. 每个对象拥有一个原型对象, 对象以其原型为模板, 从原型继承方法和属性. 原型对象也可能拥有原型, 并从中继承方法和属性, 一层一层, 以此类推. 这种关系常被称为原型链, 它解释了为何一个对象会拥有定义在其他对象中的属性和方法. 在传统的OOP中, 首先定义类, 此后创建对象实例时, 类中定义的所有属性和方法都被复制到实例中. 在 JavaScript中并不如此复制. 而是在对象实例和它的构造器之间建立一个链接(它是__proto__属性，是从构造函数的prototype属性派生的)之后通过上溯原型链, 在构造器中找到这些属性和方法. 在ES6之后不推荐使用对象__proto__属性来获取对象的原型, 通过Object.setPrototypeOf()和Object.getPrototypeOf()来分别设置和获取某个对象的原型. 

* 字面量对象的原型: 空的对象
* 通过构造函数new出来的对象: 原型对象就为构造函数的原型

## 函数的prototype

每个函数都有一个特殊的属性prototype, 可以在该属性上添加属性和方法. 当该函数作为构造函数时, 该属性就是其实例的原型

### 构造函数的prototype

通过构造函数创建出来的对象, 它们的原型就是构造函数的prototype属性, 因此构造出来的所有的对象共用一个原型, 也就是函数的prototype属性. 但是可以通过Object.setPrototypeof()去改变某个实例的原型, 但此时该对象的prototype就不是指向通过其构造函数的prototype属性

## 原型链

一个对象有自己的原型, 可是原型也可以有自己的原型, 这就构成原型链. JavaScript中就是通过原型链来模拟继承的. 最终一个原型的原型必须是Object的prototype属性, 也就是一个空对象. 

### 对象中属性和方法的查找

首先要确定的是, 原型链上的属性和方法不会复制到对象上去, 而是对象与原型之间的一种联系, 但是对象可以去访问原型链上的属性和方法. 当一个对象访问某个属性和方法时, 会沿着原型链去查找. 查找规则如下.

1. 首先会在对象的本身上去查找看有没有该属性和方法, 如果有就直接返回. 
2. 如果没有找到, 就去原型上去找, 如果找到就返回. 
3. 如果还没有找到, 就去原型的原型, 一直到原型链的最顶端, 如果找到就返回. 
4. 如果还没有找到, 返回undefined.





